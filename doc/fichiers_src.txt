/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   calcul_len.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/23 09:52:34 by mbendidi          #+#    #+#             */
/*   Updated: 2025/02/26 18:40:55 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static size_t	process_exit_variable(t_shell_env *env)
{
	size_t	len;
	char	*exit_str;

	len = 0;
	exit_str = ft_itoa(env->exit_status);
	len = ft_strlen(exit_str);
	free(exit_str);
	return (len);
}

static size_t	process_normal_variable(char *token, t_shell_env *env, int *i)
{
	size_t	len;
	char	*var_name;
	char	*var_value;
	int		var_start;
	int		var_len;

	len = 0;
	var_start = *i;
	while (token[*i] && is_valid_var_char(token[*i]))
		(*i)++;
	var_len = *i - var_start;
	var_name = ft_substr(token, var_start, var_len);
	var_value = env_get(env, var_name);
	if (var_value)
		len = ft_strlen(var_value);
	free(var_name);
	return (len);
}

static size_t	process_variable(char *token, t_shell_env *env, int *i)
{
	size_t	len;

	len = 0;
	if (!token[*i])
		return (0);
	if (token[*i] == '?')
	{
		len = process_exit_variable(env);
		(*i)++;
	}
	else if (is_valid_var_char(token[*i]))
	{
		len = process_normal_variable(token, env, i);
	}
	else
	{
		len = 2;
		(*i)++;
	}
	return (len);
}

size_t	calculate_length(char *token, t_shell_env *env, int *ctx)
{
	int		i;
	size_t	len;

	if (!ctx)
		return ((size_t)(-1));
	i = 0;
	len = 0;
	while (token[i])
	{
		if (token[i] == '\'' || token[i] == '"')
		{
			len++;
			i++;
		}
		else if (token[i] == '$' && ctx[i] != 1)
		{
			i++;
			if (!token[i])
				break ;
			len += process_variable(token, env, &i);
		}
		else
		{
			len++;
			i++;
		}
	}
	return (len);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/22 12:59:17 by mbendidi          #+#    #+#             */
/*   Updated: 2025/02/25 20:30:33 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static char	**dup_env(char **envp)
{
	int		i;
	char	**env;

	i = 0;
	while (envp[i])
		i++;
	env = malloc(sizeof(char *) * (i + 1));
	if (!env)
		return (NULL);
	i = 0;
	while (envp[i])
	{
		env[i] = ft_strdup(envp[i]);
		if (!env[i])
		{
			while (--i >= 0)
				free(env[i]);
			free(env);
			return (NULL);
		}
		i++;
	}
	env[i] = NULL;
	return (env);
}

t_shell_env	*create_shell_env(char **envp)
{
	t_shell_env	*shell_env;

	shell_env = malloc(sizeof(t_shell_env));
	if (!shell_env)
		return (NULL);
	shell_env->env = dup_env(envp);
	if (!shell_env->env)
	{
		free(shell_env);
		return (NULL);
	}
	shell_env->exit_status = 0;
	shell_env->running = 1;
	shell_env->builtins = NULL;
	return (shell_env);
}

void	destroy_shell_env(t_shell_env *shell_env)
{
	int	i;

	if (!shell_env)
		return ;
	if (shell_env->env)
	{
		i = 0;
		while (shell_env->env[i])
			free(shell_env->env[i++]);
		free(shell_env->env);
	}
	if (shell_env->builtins)
	{
		free_builtins(shell_env->builtins);
	}
	free(shell_env);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_utils2.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/22 13:05:00 by mbendidi          #+#    #+#             */
/*   Updated: 2025/02/22 13:05:43 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int	expand_env(t_shell_env *shell_env, char *new_var)
{
	char	**new_env;
	int		cnt;
	int		i;

	cnt = 0;
	while (shell_env->env[cnt])
		cnt++;
	new_env = malloc(sizeof(char *) * (cnt + 2));
	if (!new_env)
	{
		free(new_var);
		return (1);
	}
	i = 0;
	while (i < cnt)
	{
		new_env[i] = shell_env->env[i];
		i++;
	}
	new_env[cnt] = new_var;
	new_env[cnt + 1] = NULL;
	free(shell_env->env);
	shell_env->env = new_env;
	return (0);
}

int	env_set(t_shell_env *shell_env, const char *name, const char *value)
{
	char	*new_var;
	int		index;

	new_var = ft_strjoin_three(name, "=", value);
	if (!new_var)
		return (1);
	index = find_env_index(shell_env, name);
	if (index != -1)
	{
		free(shell_env->env[index]);
		shell_env->env[index] = new_var;
		return (0);
	}
	return (expand_env(shell_env, new_var));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_utils.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/22 13:01:38 by mbendidi          #+#    #+#             */
/*   Updated: 2025/02/22 13:05:41 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	find_env_index(t_shell_env *shell_env, const char *name)
{
	int	i;
	int	name_len;

	i = 0;
	name_len = ft_strlen(name);
	while (shell_env->env[i])
	{
		if (ft_strncmp(shell_env->env[i], name, name_len) == 0
			&& shell_env->env[i][name_len] == '=')
			return (i);
		i++;
	}
	return (-1);
}

char	*env_get(t_shell_env *shell_env, const char *name)
{
	int		index;
	char	*sign_egal;

	index = find_env_index(shell_env, name);
	if (index == -1)
		return (NULL);
	sign_egal = ft_strchr(shell_env->env[index], '=');
	if (!sign_egal)
		return (NULL);
	return (sign_egal + 1);
}

char	*ft_strjoin_three(const char *name, const char *eq, const char *value)
{
	char	*tmp;
	char	*result;

	tmp = ft_strjoin(name, eq);
	if (!tmp)
		return (NULL);
	result = ft_strjoin(tmp, value);
	free(tmp);
	return (result);
}

int	env_unset(t_shell_env *shell_env, const char *name)
{
	int	index;

	index = find_env_index(shell_env, name);
	if (index == -1)
		return (1);
	free(shell_env->env[index]);
	while (shell_env->env[index + 1])
	{
		shell_env->env[index] = shell_env->env[index + 1];
		index++;
	}
	shell_env->env[index] = NULL;
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   excec_built.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/22 18:48:06 by mbendidi          #+#    #+#             */
/*   Updated: 2025/02/22 18:48:54 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	is_builtin(t_shell_env *env, char *cmd_name)
{
	t_builtin	*builtins;
	int			i;

	builtins = init_builtins(env);
	i = 0;
	while (builtins[i].name)
	{
		if (ft_strcmp(builtins[i].name, cmd_name) == 0)
			return (1);
		i++;
	}
	return (0);
}

int	exec_builtin(t_cmd *cmd, t_shell_env *env)
{
	t_builtin	*builtins;
	int			i;

	builtins = init_builtins(env);
	i = 0;
	while (builtins[i].name)
	{
		if (ft_strcmp(builtins[i].name, cmd->av[0]) == 0)
			return (builtins[i].func(cmd->av, env));
		i++;
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_cmd.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jdecarro <jdecarro@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/10 17:32:41 by jdecarro          #+#    #+#             */
/*   Updated: 2025/02/27 15:15:19 by jdecarro         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	execute_commands(t_cmd *cmds, t_shell_env *env)
{
	t_cmd	*current;
	int		pipe_fd[2];
	int		prev_fd;
	pid_t	pid;
	int		saved_stdin;
	int		saved_stdout;
	t_redir	*redir;

	redir = cmds->redirs;
	prev_fd = -1;
	current = cmds;
	while (current)
	{
		saved_stdin = dup(STDIN_FILENO);
		saved_stdout = dup(STDOUT_FILENO);
		handle_redirections(current);
		if (handle_redirections(current) == -1)
		{
			ft_putstr_fd("minishell: ", 2);
			ft_putstr_fd(redir->filename, 2);
			ft_putstr_fd(": No such file or directory\n", 2);
			env->exit_status = 1;
			return ;
		}
		if (!current->next && is_builtin(env, current->av[0]))
			env->exit_status = exec_builtin(current, env);
		else
		{
			if (current->next && pipe(pipe_fd) == -1)
				return (perror("pipe"));
			pid = fork();
			if (pid == -1)
				return (perror("fork"));
			if (pid == 0)
			{
				if (prev_fd != -1)
				{
					dup2(prev_fd, STDIN_FILENO);
					close(prev_fd);
				}
				if (current->next)
				{
					dup2(pipe_fd[1], STDOUT_FILENO);
					close(pipe_fd[1]);
					close(pipe_fd[0]);
				}
				if (is_builtin(env, current->av[0]))
					exit(exec_builtin(current, env));
				else
					exit(exec_external(current, env));
			}
			else
			{
				if (prev_fd != -1)
					close(prev_fd);
				if (current->next)
				{
					close(pipe_fd[1]);
					prev_fd = pipe_fd[0];
				}
				waitpid(pid, &env->exit_status, 0);
			}
		}
		dup2(saved_stdin, STDIN_FILENO);
		dup2(saved_stdout, STDOUT_FILENO);
		close(saved_stdin);
		close(saved_stdout);
		current = current->next;
	}
	if (prev_fd != -1)
		close(prev_fd);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   external.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/22 17:36:07 by mbendidi          #+#    #+#             */
/*   Updated: 2025/02/27 18:36:11 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static void	exec_child_process(char *path, t_cmd *cmd, t_shell_env *shell_env)
{
	signal(SIGQUIT, SIG_DFL);
	execve(path, cmd->av, shell_env->env);
	perror("minishell: error Child process\n");
	free(path);
	exit(EXIT_FAILURE);
}

static int	handle_no_path(char *cmd_name)
{
	ft_putstr_fd(cmd_name, 2);
	ft_putstr_fd(": command not found\n", 2);
	return (EX_CMD_NT_FD);
}

static int	handle_fork_error(char *path, t_shell_env *shell_env)
{
	perror("minishell");
	shell_env->exit_status = 1;
	free(path);
	return (shell_env->exit_status);
}

static void	update_exit_status(t_shell_env *shell_env, int status)
{
	if (WIFEXITED(status))
		shell_env->exit_status = WEXITSTATUS(status);
	else if (WIFSIGNALED(status))
		shell_env->exit_status = EXIT_SIG_OFFSET + WTERMSIG(status);
}

int	exec_external(t_cmd *cmd, t_shell_env *shell_env)
{
	pid_t	pid;
	char	*path;
	int		status;

	path = resolve_path(cmd->av[0], shell_env->env);
	if (!path)
		return (handle_no_path(cmd->av[0]));
	pid = fork();
	if (pid < 0)
		return (handle_fork_error(path, shell_env));
	if (pid == 0)
		exec_child_process(path, cmd, shell_env);
	waitpid(pid, &status, 0);
	free(path);
	update_exit_status(shell_env, status);
	return (shell_env->exit_status);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   external_helpers.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/22 17:54:57 by mbendidi          #+#    #+#             */
/*   Updated: 2025/02/22 17:56:46 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static char	*build_path_sp(char *path, char *cmd)
{
	int	len;

	len = ft_strlen(path);
	if (path[len - 1] == '/')
		return (ft_strjoin(path, cmd));
	else
		return (ft_strjoin_three(path, "/", cmd));
}

char	*search_in_path(char *cmd, char *path_env)
{
	char		**path_sp;
	char		*str;
	int			i;

	path_sp = ft_split(path_env, ':');
	if (!path_sp)
		return (NULL);
	i = 0;
	while (path_sp[i])
	{
		str = build_path_sp(path_sp[i], cmd);
		if (access(str, X_OK) == 0)
		{
			free_av(path_sp);
			return (str);
		}
		free(str);
		i++;
	}
	free_av(path_sp);
	return (NULL);
}

char	*resolve_path(char *cmd, char **env)
{
	char	*path_env;
	int		i;

	if (!env)
		return (NULL);
	if (ft_strchr(cmd, '/'))
	{
		if (access(cmd, X_OK) == 0)
			return (ft_strdup(cmd));
		return (NULL);
	}
	path_env = NULL;
	i = 0;
	while (env[i])
	{
		if (!ft_strncmp(env[i], "PATH=", 5))
		{
			path_env = env[i] + 5;
			break ;
		}
		i++;
	}
	if (!path_env)
		return (NULL);
	return (search_in_path(cmd, path_env));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/22 12:53:09 by mbendidi          #+#    #+#             */
/*   Updated: 2025/02/25 20:24:47 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	free_builtins(t_builtin *builtins)
{
	int	i;

	i = 0;
	if (!builtins)
		return ;
	while (builtins[i].name)
	{
		free(builtins[i].name);
		i++;
	}
	free(builtins);
}

/*
	Libère une liste chaînée de redirections
	On libère d'abord le nom du fichier qui a été alloué
	Puis la structure de redirection elle-même
*/
void	free_redirs(t_redir *redirs)
{
	t_redir	*current;
	t_redir	*next;

	current = redirs;
	while (current)
	{
		next = current->next;
		if (current->filename)
			free(current->filename);
		free(current);
		current = next;
	}
}

/*
	Libère le tableau d'arguments d'une commande
	On parcourt le tableau jusqu'à NULL
	Libération de chaque argument
	Libération du tableau lui-même
*/
void	free_av(char **argv)
{
	int	i;

	if (!argv)
		return ;
	i = 0;
	while (argv[i])
	{
		free(argv[i]);
		i++;
	}
	free(argv);
}

/*
	Fonction principale qui libère toute la liste de commandes
	On libère d'abord les redirections de la commande
	Puis les arguments
	Enfin la structure de commande elle-même
*/
void	free_cmds(t_cmd *cmds)
{
	t_cmd	*current;
	t_cmd	*next;

	current = cmds;
	while (current)
	{
		next = current->next;
		if (current->redirs)
			free_redirs(current->redirs);
		if (current->av)
			free_av(current->av);
		free(current);
		current = next;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_cd.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jdecarro <jdecarro@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/10 17:32:41 by jdecarro          #+#    #+#             */
/*   Updated: 2025/02/10 17:32:41 by jdecarro         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	ft_cd(char **args, t_shell_env *shell_env)
{
	char		*path;
	char		new_pwd[PATH_MAX];
	struct stat	path_stat;

	if (!args[1] || ft_strcmp(args[1], "~") == 0 || ft_strcmp(args[1], "") == 0)
		path = env_get(shell_env, "HOME");
	else
		path = args[1];
	if (args[1] && args[2])
	{
		ft_putstr_fd("minishell: cd: too many arguments\n", 2);
		shell_env->exit_status = 1;
		return (1);
	}
	if (stat(path, &path_stat) == 0 && !S_ISDIR(path_stat.st_mode))
	{
		ft_putstr_fd("cd: ", 2);
		ft_putstr_fd(path, 2);
		ft_putstr_fd(": Not a directory\n", 2);
		shell_env->exit_status = 1;
		return (1);
	}
	if (chdir(path) != 0)
	{
		ft_putstr_fd("minishell: cd: ", 2);
		ft_putstr_fd(path, 2);
		ft_putstr_fd(": No such file or directory\n", 2);
		shell_env->exit_status = 1;
		return (1);
	}
	if (getcwd(new_pwd, sizeof(new_pwd)) != NULL)
	{
		env_set(shell_env, "OLDPWD", env_get(shell_env, "PWD"));
		env_set(shell_env, "PWD", new_pwd);
	}
	shell_env->exit_status = 0;
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_echo.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jdecarro <jdecarro@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/31 09:41:26 by jdecarro          #+#    #+#             */
/*   Updated: 2025/01/31 09:41:26 by jdecarro         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static bool	check_option_echo(const char *str)
{
	int	i;

	if (!str || str[0] != '-')
		return (0);
	i = 1;
	if (!str[i])
		return (false);
	while (str[i] == 'n')
		i++;
	return (str[i] == '\0');
}

static void	write_echo(int i, bool new_line, char **args)
{
	bool	first;

	first = true;
	while (args[i])
	{
		if (!first)
			write(1, " ", 1);
		write(1, args[i], ft_strlen(args[i]));
		first = false;
		i++;
	}
	if (new_line)
		write(1, "\n", 1);
}

int	ft_echo(char **args, t_shell_env *shell_env)
{
	int		i;
	bool	new_line;

	(void)shell_env;
	i = 1;
	new_line = true;
	while (args[i] && check_option_echo(args[i]))
	{
		new_line = false;
		i++;
	}
	write_echo(i, new_line, args);
	return (0);
}

// int main(int argc, char **argv)
// {
// 	ft_echo(argv);
// 	return (0);
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_env.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jdecarro <jdecarro@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/04 15:43:00 by jdecarro          #+#    #+#             */
/*   Updated: 2025/02/04 15:43:00 by jdecarro         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	ft_env(char **argv, t_shell_env *shell_env)
{
	int	i;

	(void)argv;
	i = 0;
	while (shell_env->env[i])
	{
		printf("%s\n", shell_env->env[i]);
		i++;
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_exit.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jdecarro <jdecarro@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/13 16:04:51 by jdecarro          #+#    #+#             */
/*   Updated: 2025/02/13 16:04:51 by jdecarro         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	ft_is_numeric(const char *str)
{
	int	i;

	i = 0;
	if (!str || !str[i])
		return (0);
	if (str[i] == '-' || str[i] == '+')
		i++;
	while (str[i])
	{
		if (!ft_isdigit(str[i]))
			return (0);
		i++;
	}
	return (1);
}

long	ft_atol(const char *str, int *error)
{
	int		i;
	int		sign;
	long	result;

	i = 0;
	sign = 1;
	result = 0;
	if (str[i] == '-' || str[i] == '+')
	{
		if (str[i] == '-')
			sign = -1;
		i++;
	}
	while (str[i])
	{
		if (!ft_isdigit(str[i]))
		{
			*error = 1;
			return (0);
		}
		if ((result > LONG_MAX / 10)
			|| (result == LONG_MAX / 10 && (str[i] - '0') > LONG_MAX % 10))
		{
			*error = 1;
			return (0);
		}
		result = result * 10 + (str[i] - '0');
		i++;
	}
	return (result * sign);
}

int	ft_exit(char **args, t_shell_env *shell)
{
	long	exit_code;
	int		error;

	error = 0;
	ft_putstr_fd("exit\n", 1);
	if (!args[1])
		exit(shell->exit_status);
	if (!ft_is_numeric(args[1]))
	{
		ft_putstr_fd("minishell: exit: ", 2);
		ft_putstr_fd(args[1], 2);
		ft_putstr_fd(": numeric argument required\n", 2);
		exit(255);
	}
	exit_code = ft_atol(args[1], &error);
	if (error)
	{
		ft_putstr_fd("minishell: exit: ", 2);
		ft_putstr_fd(args[1], 2);
		ft_putstr_fd(": numeric argument required\n", 2);
		exit(255);
	}
	if (args[2])
	{
		ft_putstr_fd("minishell: exit: too many arguments\n", 2);
		shell->exit_status = 1;
		return (1);
	}
	exit(exit_code % 256);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_export.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jdecarro <jdecarro@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/05 08:54:23 by jdecarro          #+#    #+#             */
/*   Updated: 2025/02/05 08:54:23 by jdecarro         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int	check_export_name(char *args)
{
	int	i;

	if (!args || !args[0] || args[0] == '=' || ft_isdigit(args[0]))
		return (0);
	i = 0;
	while (args[i] && args[i] != '=')
	{
		if (!ft_isalnum(args[i]) && args[i] != '_')
			return (0);
		i++;
	}
	return (1);
}

static char	**ft_copy_env(char **env)
{
	int		i;
	char	**new_env;

	i = 0;
	while (env[i])
		i++;
	new_env = malloc(sizeof(char *) * (i + 1));
	if (!new_env)
		return (NULL);
	i = 0;
	while (env[i])
	{
		new_env[i] = ft_strdup(env[i]);
		if (!new_env[i])
		{
			while (i-- > 0)
				free(new_env[i]);
			free(new_env);
			return (NULL);
		}
		i++;
	}
	new_env[i] = NULL;
	return (new_env);
}

static void	ft_sort_env(char **env)
{
	int		i;
	int		j;
	char	*tmp;

	i = 0;
	while (env[i])
	{
		j = i + 1;
		while (env[j])
		{
			if (ft_strcmp(env[i], env[j]) > 0)
			{
				tmp = env[i];
				env[i] = env[j];
				env[j] = tmp;
			}
			j++;
		}
		i++;
	}
}

static void	ft_print_sorted_env(char **env)
{
	int		i;
	int		j;
	char	**sorted_env;

	sorted_env = ft_copy_env(env);
	if (!sorted_env)
		return ;
	ft_sort_env(sorted_env);
	i = 0;
	while (sorted_env[i])
	{
		ft_printf("declare -x ");
		j = 0;
		while (sorted_env[i][j] && sorted_env[i][j] != '=')
			ft_printf("%c", sorted_env[i][j++]);
		if (sorted_env[i][j] && sorted_env[i][j] == '=')
			ft_printf("=\"%s\"\n", &sorted_env[i][j + 1]);
		else
			ft_printf("\n");
		free(sorted_env[i]);
		i++;
	}
	free(sorted_env);
}

int	ft_export(char **args, t_shell_env *shell_env)
{
	int		i;
	char	**new_env;

	if (!args || !args[0] || !shell_env)
		return (1);
	if (!args[1])
	{
		ft_print_sorted_env(shell_env->env);
		return (0);
	}
	if (!check_export_name(args[1]))
	{
		ft_printf("minishell: export: `%s': not a valid identifier\n", args[1]);
		return (1);
	}
	i = 0;
	while (shell_env->env[i])
	{
		if (ft_strncmp(shell_env->env[i], args[1], ft_strchr(args[1], '=') - args[1]) == 0)
		{
			free(shell_env->env[i]);
			shell_env->env[i] = ft_strdup(args[1]);
			return (0);
		}
		i++;
	}
	new_env = malloc(sizeof(char *) * (i + 2));
	if (!new_env)
		return (1);
	i = 0;
	while (shell_env->env[i])
	{
		new_env[i] = shell_env->env[i];
		i++;
	}
	new_env[i] = ft_strdup(args[1]);
	new_env[i + 1] = NULL;
	free(shell_env->env);
	shell_env->env = new_env;
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_pwd.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jdecarro <jdecarro@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/31 14:24:10 by jdecarro          #+#    #+#             */
/*   Updated: 2025/01/31 14:24:10 by jdecarro         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	ft_pwd(char **argv, t_shell_env *shell_env)
{
	char	cwd[PATH_MAX];

	(void)argv;
	(void)shell_env;
	if (getcwd(cwd, sizeof(cwd)))
	{
		printf("%s\n", cwd);
		return (0);
	}
	else
	{
		perror("pwd");
		return (1);
	}
}

// int	main(int argc, char **argv)
// {
// 	ft_pwd();
// 	return (0);
// }
// int main ()
// {
// 	int i;
// 	i = 0;
// 	t_builtin g_builtins[] = {
// 		{"cd",     &builtin_cd},
// 		{"exit",   &builtin_exit},
// 		{"pwd",    &builtin_pwd},
// 		{"echo",   &builtin_echo},
// 		{"env",    &builtin_env},
// 		{"export", &builtin_export},
// 		{"unset",  &builtin_unset},
// 		{NULL,     NULL}
// 	};
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_redirects.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jdecarro <jdecarro@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/21 09:08:28 by jdecarro          #+#    #+#             */
/*   Updated: 2025/02/21 09:08:28 by jdecarro         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	handle_heredoc(char *delimiter, int *heredoc_fd)
{
	int		pipe_fd[2];
	char	*line;

	if (pipe(pipe_fd) == -1)
	{
		perror("pipe");
		return ;
	}
	while (1)
	{
		line = readline("> ");
		if (!line || ft_strcmp(line, delimiter) == 0)
		{
			free(line);
			break ;
		}
		write(pipe_fd[1], line, ft_strlen(line));
		write(pipe_fd[1], "\n", 1);
		free(line);
	}
	close(pipe_fd[1]); //Fermeture du côté écriture du pipe
	*heredoc_fd = pipe_fd[0]; // tocke la lecture
}

int	handle_redirections(t_cmd *cmd)
{
	int		fd;
	t_redir	*redir;
	int		heredoc_fd;

	heredoc_fd = -1;
	if (!cmd || !cmd->redirs)
		return (0);
	redir = cmd->redirs;
	while (redir)
	{
		fd = -1;
		if (redir->type == REDIR_HEREDOC)
		{
			handle_heredoc(redir->filename, &heredoc_fd);
			fd = heredoc_fd;
		}
		else if (redir->type == REDIR_IN)
			fd = open(redir->filename, O_RDONLY);
		else if (redir->type == REDIR_OUT)
			fd = open(redir->filename, O_CREAT | O_WRONLY | O_TRUNC, 0644);
		else if (redir->type == REDIR_APPEND)
			fd = open(redir->filename, O_CREAT | O_WRONLY | O_APPEND, 0644);
		if (fd == -1 && redir->type != REDIR_HEREDOC)
			return (-1);
		if (fd != -1)
		{ 
			if (redir->type == REDIR_IN || redir->type == REDIR_HEREDOC)
				dup2(fd, STDIN_FILENO);
			else
				dup2(fd, STDOUT_FILENO);
			close(fd);
		}
		redir = redir->next;
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_unset.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jdecarro <jdecarro@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/11 10:34:06 by jdecarro          #+#    #+#             */
/*   Updated: 2025/02/27 13:55:11 by jdecarro         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int	check_unset_name(char *args)
{
	int	i;

	if (!args || !args[0] || args[0] == '=' || ft_isdigit(args[0]))
		return (0);
	i = 0;
	while (args[i] && args[i] != '=')
	{
		if (!ft_isalnum(args[i]) && args[i] != '_')
			return (0);
		i++;
	}
	return (1);
}

int	ft_unset(char **args, t_shell_env *shell_env)
{
	int	i;
	int	j;
	int	len;

	i = 1;
	if (!args[1])
		return (0);
	if (!check_unset_name(args[1]))
	{
		ft_printf("minishell: unset: `%s': not a valid identifier\n", args[1]);
		return (1);
	}
	while (args[i])
	{
		len = ft_strlen(args[i]);
		j = 0;
		while (shell_env->env[j])
		{
			if (ft_strncmp(shell_env->env[j], args[i], len) == 0
				&& shell_env->env[j][len] == '=')
			{
				free(shell_env->env[j]);
				while (shell_env->env[j])
				{
					shell_env->env[j] = shell_env->env[j + 1];
					j++;
				}
				break ;
			}
			j++;
		}
		i++;
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_token.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/24 20:04:37 by mbendidi          #+#    #+#             */
/*   Updated: 2025/02/24 20:06:08 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static void	handle_backslash(t_tokenizer *tok)
{
	if (tok->data->line[tok->pos + 1])
	{
		tok->pos++;
		fill_buffer_and_ctx(tok);
		tok->pos++;
	}
	else
	{
		fill_buffer_and_ctx(tok);
		tok->pos++;
	}
}

static void	handle_quote_char(t_tokenizer *tok)
{
	char	c;

	c = tok->data->line[tok->pos];
	if (!tok->quote)
	{
		if (c == '\'')
			tok->quote = 1;
		else if (c == '\"')
			tok->quote = 2;
	}
	else if ((tok->quote == 1 && c == '\'') || (tok->quote == 2 && c == '"'))
		tok->quote = 0;
	else
		fill_buffer_and_ctx(tok);
	tok->pos++;
}

static void	parse_token(t_tokenizer *tok)
{
	while (tok->pos < tok->total && tok->data->line[tok->pos])
	{
		if (tok->data->line[tok->pos] == '\\')
			handle_backslash(tok);
		else if (tok->data->line[tok->pos] == '\''
			|| tok->data->line[tok->pos] == '"')
		{
			handle_quote_char(tok);
		}
		else
		{
			if (!tok->quote && ft_isspace(tok->data->line[tok->pos]))
				break ;
			fill_buffer_and_ctx(tok);
			tok->pos++;
		}
	}
	tok->buffer[tok->len] = '\0';
}

static void	skip_spaces(t_tokenizer *tok)
{
	while (tok->data->line[tok->pos] && ft_isspace(tok->data->line[tok->pos]))
		tok->pos++;
}

char	*get_next_token(t_shell_env *env, t_data *data)
{
	t_tokenizer	tok;
	char		*token;

	tok.data = data;
	tok.env = env;
	tok.pos = 0;
	tok.len = 0;
	tok.quote = 0;
	skip_spaces(&tok);
	data->line += tok.pos;
	tok.pos = 0;
	tok.total = ft_strlen(data->line);
	if (!tok.total)
		return (NULL);
	if (!alloc_buffer(&tok))
		return (NULL);
	parse_token(&tok);
	data->line += tok.pos;
	token = expand_token(&tok);
	return (token);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_n_t_helper.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/24 19:30:19 by mbendidi          #+#    #+#             */
/*   Updated: 2025/02/25 20:39:59 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	alloc_buffer(t_tokenizer *tok)
{
	tok->buffer = malloc(sizeof(char) * (tok->total + 1));
	tok->token_ctx = malloc(sizeof(int) * (tok->total + 1));
	if (!tok->buffer || !tok->token_ctx)
	{
		if (tok->buffer)
			free(tok->buffer);
		if (tok->token_ctx)
			free(tok->token_ctx);
		return (0);
	}
	return (1);
}

void	fill_buffer_and_ctx(t_tokenizer *tok)
{
	tok->buffer[tok->len] = tok->data->line[tok->pos];
	tok->token_ctx[tok->len] = tok->quote;
	tok->len++;
}

char	*expand_token(t_tokenizer *tok)
{
	char	*token;
	int		*old_ctx;
	size_t	old_cpos;

	if (!ft_strchr(tok->buffer, '$'))
	{
		free(tok->token_ctx);
		return (tok->buffer);
	}
	old_ctx = tok->data->ctx;
	old_cpos = tok->data->cpos;
	tok->data->ctx = tok->token_ctx;
	tok->data->cpos = 0;
	token = remplacer_var(tok->buffer, tok->env, tok->data);
	free(tok->buffer);
	free(tok->token_ctx);
	tok->data->ctx = old_ctx;
	tok->data->cpos = old_cpos;
	return (token);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init_builtins.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/22 18:38:15 by mbendidi          #+#    #+#             */
/*   Updated: 2025/02/22 19:21:11 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static void	init_builtin_entries(t_builtin *builtins)
{
	builtins[0].name = ft_strdup("cd");
	builtins[0].func = &ft_cd;
	builtins[1].name = ft_strdup("exit");
	builtins[1].func = &ft_exit;
	builtins[2].name = ft_strdup("pwd");
	builtins[2].func = &ft_pwd;
	builtins[3].name = ft_strdup("echo");
	builtins[3].func = &ft_echo;
	builtins[4].name = ft_strdup("env");
	builtins[4].func = &ft_env;
	builtins[5].name = ft_strdup("export");
	builtins[5].func = &ft_export;
	builtins[6].name = ft_strdup("unset");
	builtins[6].func = &ft_unset;
	builtins[7].name = NULL;
	builtins[7].func = NULL;
}

t_builtin	*init_builtins(t_shell_env *shell_env)
{
	if (shell_env->builtins == NULL)
	{
		shell_env->builtins = malloc(sizeof(t_builtin) * 8);
		if (!shell_env->builtins)
		{
			perror("error malloc builtins");
			exit(EXIT_FAILURE);
		}
		init_builtin_entries(shell_env->builtins);
	}
	return (shell_env->builtins);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jdecarro <jdecarro@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/22 12:15:51 by mbendidi          #+#    #+#             */
/*   Updated: 2025/02/27 13:55:30 by jdecarro         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static void	handle_signal(t_shell_env *shell_env)
{
	if (g_received_signal)
	{
		if (g_received_signal == SIGINT)
			shell_env->exit_status = 130;
		g_received_signal = 0;
	}
}

static void	process_iteration(t_shell_env *shell_env)
{
	char		*cmd_line;
	t_cmd		*cmds;

	cmd_line = readline("\001\033[1;35m\002Minishell> \001\033[0m\002");
	if (!cmd_line)
	{
		printf("exit\n");
		shell_env->running = 0;
		return ;
	}
	if (*cmd_line)
		add_history(cmd_line);
	handle_signal(shell_env);
	cmds = parse_command_line(cmd_line, shell_env);
	if (cmds == NULL)
		shell_env->exit_status = 258;
	else if (cmds->next)
	{
		exec_pipes(cmds, shell_env);
		free_cmds(cmds);
	}
	else
	{
		execute_commands(cmds, shell_env);
		free_cmds(cmds);
	}
	free(cmd_line);
}

int	main(int ac, char **av, char **envp)
{
	t_shell_env	*shell_env;
	int			ret;

	if (ac == 1)
	{
		shell_env = create_shell_env(envp);
		if (!shell_env)
			return (1);
		signal_setup();
		while (shell_env->running)
			process_iteration(shell_env);
		ret = shell_env->exit_status;
		destroy_shell_env(shell_env);
		return (ret);
	}
	else
	{
		ft_putstr_fd("minishell: ", 2);
		write(2, av[1], ft_strlen(av[1]));
		ft_putstr_fd(": No such file or directory\n", 2);
		return (1);
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse1_utils.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/22 19:27:04 by mbendidi          #+#    #+#             */
/*   Updated: 2025/02/23 10:26:19 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	is_valid_var_char(char c)
{
	return (ft_isalnum(c) || c == '_');
}

char	*remove_quotes(char *token)
{
	int		len;
	char	*new_token;

	if (!token)
		return (NULL);
	len = ft_strlen(token);
	if (len < 2)
		return (token);
	if ((token[0] == '\'' && token[len - 1] == '\'') || (token[0] == '"'
			&& token[len - 1] == '"'))
	{
		new_token = ft_substr(token, 1, len - 2);
		free(token);
		return (new_token);
	}
	return (token);
}

int	count_tokens(char *str)
{
	int		count;
	int		in_word;
	int		i;
	char	quote;

	count = 0;
	in_word = 0;
	i = 0;
	quote = 0;
	while (str[i])
	{
		if (!ft_isspace(str[i]))
		{
			if (!in_word)
			{
				in_word = 1;
				count++;
				if (str[i] == '\'' || str[i] == '"')
				{
					quote = str[i];
					i++;
					while (str[i] && str[i] != quote)
						i++;
					if (str[i] == quote)
						i++;
					in_word = 0;
				}
			}
			else
				i++;
		}
		else
		{
			in_word = 0;
			i++;
		}
	}
	return (count);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse2_utils.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/22 18:01:13 by mbendidi          #+#    #+#             */
/*   Updated: 2025/02/22 19:16:12 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static void	check_quote(char c, int *quote)
{
	if (c == '\'' && *quote != 2)
	{
		if (*quote == 0)
			*quote = 1;
		else
			*quote = 0;
	}
	else if (c == '"' && *quote != 1)
	{
		if (*quote == 0)
			*quote = 2;
		else
			*quote = 0;
	}
}

static int	remplir_quotes_context(const char *line, int *context)
{
	int	i;
	int	quote;

	i = 0;
	quote = 0;
	while (line[i])
	{
		check_quote(line[i], &quote);
		context[i++] = quote;
	}
	context[i] = 0;
	return (quote);
}

void	*get_quotes_context(t_data *data)
{
	if (!data->line)
		return (NULL);
	data->ctx = malloc(sizeof(int) * (ft_strlen(data->line) + 1));
	if (!data->ctx)
		return (NULL);
	if (remplir_quotes_context(data->line, data->ctx) != 0)
	{
		ft_putendl_fd("minishell: syntax error: unclosed quote", 2);
		free(data->ctx);
		return (NULL);
	}
	return (data);
}

static char	**create_new_argv(char **av, int len)
{
	char	**new_av;
	int		i;

	new_av = malloc(sizeof(char *) * (len + 2));
	if (!new_av)
		return (NULL);
	i = 0;
	while (i < len)
	{
		new_av[i] = av[i];
		i++;
	}
	return (new_av);
}

char	**add_to_argv(char **av, const char *token)
{
	char	**new_av;
	int		len;

	if (!av || !av[0])
		return (init_argv(token));
	len = 0;
	while (av[len])
		len++;
	new_av = create_new_argv(av, len);
	if (!new_av)
		return (NULL);
	new_av[len] = ft_strdup(token);
	new_av[len + 1] = NULL;
	free(av);
	return (new_av);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_cmd.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jdecarro <jdecarro@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/22 15:50:28 by mbendidi          #+#    #+#             */
/*   Updated: 2025/02/27 13:55:37 by jdecarro         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	init_cmd_ifneed(t_cmd **cmd, t_cmd **cur_cmd)
{
	if (!*cmd)
	{
		*cmd = malloc(sizeof(t_cmd));
		if (!*cmd)
			return (0);
		*cur_cmd = *cmd;
		(*cur_cmd)->next = NULL;
		(*cur_cmd)->av = NULL;
		(*cur_cmd)->redirs = NULL;
	}
	return (1);
}

t_cmd	*parse_tokens(t_data *data, t_shell_env *env)
{
	t_cmd	*cmd;
	t_cmd	*cur_cmd;
	char	*token;

	cmd = NULL;
	cur_cmd = NULL;
	while (1)
	{
		token = get_next_token(env, data);
		if (!token)
			break ;
		if (!init_cmd_ifneed(&cmd, &cur_cmd))
		{
			free_cmds(cmd);
			return (NULL);
		}
		if (!process_token(token, data, env, &cur_cmd))
		{
			free_cmds(cmd);
			return (NULL);
		}
	}
	return (cmd);
}

int	final_verification(t_cmd *cmd)
{
	t_cmd	*cur_cmd;

	cur_cmd = cmd;
	while (cur_cmd->next)
		cur_cmd = cur_cmd->next;
	if (!cur_cmd->av || cur_cmd->av[0] == NULL)
	{
		ft_putendl_fd("minishell: syntax error near unexpected token `|'", 2);
		free_cmds(cmd);
		return (0);
	}
	return (1);
}

t_cmd	*parse_command_line(char *line, t_shell_env *env)
{
	t_data	data;
	t_cmd	*cmd;

	if (!line)
		return (NULL);
	data.line = line;
	data.cpos = 0;
	if (!get_quotes_context(&data))
		return (NULL);
	cmd = parse_tokens(&data, env);
	if (!cmd)
	{
		free(data.ctx);
		return (NULL);
	}
	if (!final_verification(cmd))
	{
		free(data.ctx);
		return (NULL);
	}
	free(data.ctx);
	return (cmd);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_helpers.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/22 18:28:15 by mbendidi          #+#    #+#             */
/*   Updated: 2025/02/22 18:30:31 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	**init_argv(const char *token)
{
	char	**new_av;

	new_av = malloc(sizeof(char *) * 2);
	if (!new_av)
		return (NULL);
	new_av[0] = ft_strdup(token);
	new_av[1] = NULL;
	return (new_av);
}


#include "minishell.h"

char	*remplacer_var(char *token, t_shell_env *env, t_data *data)
{
	char	*new;
	char	*var_name;
	char	*var_value;
	int		var_start;
	int		var_len;
	size_t	len_token;
	int		i;
	int		j;
	char	*exit_str;
	size_t	var_v_len;

	if (ft_strcmp(token, "$") == 0)
	{
		new = ft_strdup(token);
		return (new);
	}
	len_token = calculate_length(token, env, data->ctx);
	new = (char *)malloc(sizeof(char) * (len_token + 1));
	if (!new)
		return (NULL);
	i = 0;
	j = 0;
	var_len = 0;
	var_start = 0;
	var_v_len = 0;
	exit_str = NULL;
	if (!data->ctx)
		return (NULL);
	while (token[i])
	{
		if (token[i] != '$')
		{
			new[j] = token[i];
			i++;
			j++;
			data->cpos++;
		}
		else if (token[i] == '$' && data->ctx[data->cpos] != 1)
		{
			i++;
			data->cpos++;
			if (!token[i])
			{
				new[j] = '$';
				j++;
				break ;
			}
			else if (token[i] == '?')
			{
				exit_str = ft_itoa(env->exit_status);
				ft_memcpy(new + j, exit_str, ft_strlen(exit_str));
				i++;
				data->cpos++;
				j += ft_strlen(exit_str);
				free(exit_str);
			}
			else if (!is_valid_var_char(token[i]))
			{
				new[j++] = '$';
				new[j++] = token[i];
				i++;
				data->cpos++;
			}
			else
			{
				var_start = i;
				while (token[i] && is_valid_var_char(token[i]))
				{
					i++;
					data->cpos++;
				}
				var_len = i - var_start;
				var_name = ft_substr(token, var_start, var_len);
				var_value = env_get(env, var_name);
				if (var_value)
				{
					var_v_len = ft_strlen(var_value);
					if (j + var_v_len > len_token)
					{
						ft_putstr_fd("error: Not enough space in the buffer to copy\n", 2);
						ft_putstr_fd(var_value, 2);
						ft_putendl_fd("\"", 2);
						free(var_name);
						return (NULL);
					}
					ft_memcpy(new + j, var_value, var_v_len);
					j += var_v_len;
				}
				free(var_name);
			}
		}
		else if (token[i] == '$' && data->ctx[data->cpos] == 1)
		{
			while (token[i] && data->ctx[data->cpos] == 1)
			{
				new[j] = token[i];
				i++;
				j++;
			}
		}
	}
	new[j] = '\0';
	return (new);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pipes.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jdecarro <jdecarro@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/20 09:25:52 by mbendidi          #+#    #+#             */
/*   Updated: 2025/02/27 13:56:11 by jdecarro         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int	ft_lstsize_cmd(t_cmd *cmds)
{
	int		size;
	t_cmd	*cur;

	size = 0;
	cur = cmds;
	while (cur)
	{
		cur = cur->next;
		size++;
	}
	return (size);
}

int	exec_pipes(t_cmd *cmds, t_shell_env *env)
{
	t_cmd	*cur;
	pid_t	*pids;
	int		prev_fd;
	int		fd[2];
	int		status;
	int		i;
	int		cmd_count;

	prev_fd = -1;
	cmd_count = ft_lstsize_cmd(cmds);
	pids = malloc(sizeof(pid_t) * cmd_count);
	if (!pids)
	{
		perror("error PID allocation");
		exit(EXIT_FAILURE);
	}
	i = 0;
	cur = cmds;
	while (cur)
	{
		if (cur->next && pipe(fd) < 0)
		{
			perror("error pipe");
			free(pids);
			exit(EXIT_FAILURE);
		}
		pids[i] = fork();
		if (pids[i] < 0)
		{
			perror("error fork");
			free(pids);
			exit(EXIT_FAILURE);
		}
		if (pids[i] == 0)
		{
			handle_redirections(cur);
			if (prev_fd != -1)
			{
				dup2(prev_fd, STDIN_FILENO); //Lire depuis le pipe précédent
				close(prev_fd);
			}
			if (cur->next)
			{
				dup2(fd[1], STDOUT_FILENO); //Écrire dans le pipe suivant
				close(fd[1]);
				close(fd[0]);
			}
			if (is_builtin(env, cur->av[0]))
				exit(exec_builtin(cur, env));
			else
				exit(exec_external(cur, env));
		}
		else
		{
			if (prev_fd != -1)
				close(prev_fd); //Fermer le fd prev
			if (cur->next)
			{
				close(fd[1]); // Fermer le writedu pipe
				prev_fd = fd[0]; // Garder le read pour la prochaine commande
			}
		}
		cur = cur->next;
		i++;
	}
	while (i-- > 0)
		waitpid(pids[i], &status, 0);
	if (WIFEXITED(status))
		env->exit_status = WEXITSTATUS(status);
	else if (WIFSIGNALED(status))
		env->exit_status = WTERMSIG(status);
	free(pids);
	return (env->exit_status);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   proc_tokens.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jdecarro <jdecarro@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/22 15:39:21 by mbendidi          #+#    #+#             */
/*   Updated: 2025/02/27 13:56:20 by jdecarro         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	handle_pipe(t_cmd **cur_cmd)
{
	if (!(*cur_cmd)->av || (*cur_cmd)->av[0] == NULL)
	{
		ft_putendl_fd("minishell: syntax error near unexpected token `|'", 2);
		return (0);
	}
	(*cur_cmd)->next = malloc(sizeof(t_cmd));
	if (!(*cur_cmd)->next)
		return (0);
	*cur_cmd = (*cur_cmd)->next;
	(*cur_cmd)->av = NULL;
	(*cur_cmd)->redirs = NULL;
	(*cur_cmd)->next = NULL;
	return (1);
}

int	handle_redir(char *token, t_data *data, t_shell_env *env, t_cmd **cur_cmd)
{
	t_redir_type	type;
	char			*filename;

	type = get_redir_type(token);
	filename = get_next_token(env, data);
	if (!filename)
	{
		ft_putendl_fd("minishell: syntax error: unexpected newline", 2);
		free(token);
		return (0);
	}
	add_redir_to_cmd(*cur_cmd, type, filename);
	free(filename);
	free(token);
	return (1);
}

int	process_token(char *token, t_data *data, t_shell_env *env, t_cmd **cur_cmd)
{
	if (!ft_strcmp(token, "|"))
	{
		free(token);
		if (!handle_pipe(cur_cmd))
			return (0);
	}
	else if (is_redir(token))
	{
		if (!handle_redir(token, data, env, cur_cmd))
			return (0);
	}
	else
	{
		(*cur_cmd)->av = add_to_argv((*cur_cmd)->av, token);
		free(token);
	}
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   redir.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jdecarro <jdecarro@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/10 17:32:41 by jdecarro          #+#    #+#             */
/*   Updated: 2025/02/27 12:49:09 by jdecarro         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	is_redir(char *token)
{
	return (ft_strcmp(token, "<") == 0 || ft_strcmp(token, ">") == 0
		|| ft_strcmp(token, "<<") == 0 || ft_strcmp(token, ">>") == 0);
}

t_redir_type	get_redir_type(char *token)
{
	if (ft_strcmp(token, "<") == 0)
		return (REDIR_IN);
	if (ft_strcmp(token, ">") == 0)
		return (REDIR_OUT);
	if (ft_strcmp(token, ">>") == 0)
		return (REDIR_APPEND);
	if (ft_strcmp(token, "<<") == 0)
		return (REDIR_HEREDOC);
	return (REDIR_OUT);
}

void	add_redir_to_cmd(t_cmd *cmd, t_redir_type type, char *filename)
{
	t_redir	*new_rd;
	t_redir	*tmp;

	new_rd = malloc(sizeof(t_redir));
	if (!new_rd)
		return ;
	new_rd->type = type;
	new_rd->filename = ft_strdup(filename);
	new_rd->next = NULL;
	if (cmd->redirs == NULL)
		cmd->redirs = new_rd;
	else
	{
		tmp = cmd->redirs;
		while (tmp->next)
			tmp = tmp->next;
		tmp->next = new_rd;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   signal.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mbendidi <mbendidi@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/22 12:49:19 by mbendidi          #+#    #+#             */
/*   Updated: 2025/02/22 12:52:49 by mbendidi         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

// Seule variable globale autorisée
int			g_received_signal = 0;

static void	signal_handler(int signum)
{
	g_received_signal = signum;
	if (signum == SIGINT)
	{
		write(1, "\n", 1);
		rl_on_new_line();
		rl_replace_line("", 0);
		rl_redisplay();
	}
}

void	signal_setup(void)
{
	signal(SIGINT, signal_handler);
	signal(SIGQUIT, SIG_IGN);
}
